{"meta":{"title":"my life","subtitle":"the great day","description":"record my life","author":"sbw","url":"https://sbw6788778.github.io/blog"},"pages":[],"posts":[{"title":"RESTful service api","slug":"RESTful-service-api","date":"2017-08-18T06:31:55.000Z","updated":"2017-08-18T06:53:13.582Z","comments":true,"path":"2017/08/18/RESTful-service-api/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/08/18/RESTful-service-api/","excerpt":"","text":"RESTful 风格的服务器api的设计 有关于rest的一些理解：资源的表述层状态转移是它的直接解释，他最有用的是软件设计的一种风格（前后端交互的方式)基于http协议它的主要的作用是可以统一web，android和ios对于资源的get，post，update，delete。服务器用统一的api就可以的了。我理解的是只用返回数据，不用管显示方面的东西。即将1资源看作第一位的（它把一些服务也看成资源） 2表述层就是资源的一种表现形式（前后端传的是什么格式的资源）一般是json。 3状态变化：这里说的是资源的状态变化主要是通过http的GET,POST,UPDATE,DELETE,来实现资源的请求修改删除。最简洁的表述是：用uri来定位资源，用http的动词来描述对资源的操作。对于url的表现是：不用动词，只用名词来表述和定位资源（操作用http的来表示）","categories":[],"tags":[]},{"title":"something about js,ajax,jquery","slug":"something-about-js-ajax-jquery","date":"2017-08-17T13:45:40.000Z","updated":"2017-08-17T14:05:54.423Z","comments":true,"path":"2017/08/17/something-about-js-ajax-jquery/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/08/17/something-about-js-ajax-jquery/","excerpt":"","text":"最近看了看有关于前端交互方面的东西，第一本书是看的《js dom编程艺术》将的很有意思的入门书 下面说说我对前端的一些东西的认识。 1 首先是html主要是页面的内容的一些展示，css是html标签的布局和美化，js是对html的元素操作实现 一些人和网站的更好的交互，ajax是异步的动态加载，可以不用重新请求所有的页面而只改变部分的内容， jquery是js的一个框架，将一些繁杂的js代码用更简单的方式来实现。 2 关于前端页面的设计，一个思路是尽量将html代码css代码和js代码分开放到不同文件，这样就更加的 模块化，修改起来也更加的方便，这些不同的文件可以通过特殊的标签进行链接，css用&lt;link&gt;，js用 &lt;script scr=&quot;&quot;&gt;。 3 css中可以通过html中的属性class id（和定义css的名字相同） 来进行表示那个元素使用这一段css 4 js中最主要的功能在于html元素的选择，他可以通过id 或tags来选择想要的html元素对象，然后用它 可以查看这个元素的信息，修改元素的属性，文本的内容，或者是添加事件（绑定到指定的js函数） getelemensbyid之类的方法。 5 jquery就是将这种元素的选择简化了$()就可以选择元素，要是通过id来里面就是&quot;#id&quot;元素类型&quot;tag&quot; class属性&quot;.class&quot;,除了这些基本的还可以进行复杂的选择。","categories":[],"tags":[]},{"title":"https","slug":"https","date":"2017-07-30T02:36:12.000Z","updated":"2017-07-30T02:43:49.512Z","comments":true,"path":"2017/07/30/https/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/30/https/","excerpt":"","text":"相关的概念：1 通常在加密之前的叫做明文，加密之后的数据叫做密文。2 密钥：只有有了正确的密钥才能对密文进行解码。（不同的密钥的编码解码方式是不同的算法的主体是相同的但是细节不同由于有了密钥的存在能有这个算法衍生出许许多多的衍生算法）加密技术有对称加密和非对称加密，3 对称加密是：编码和解码用的是同样的密钥，这样带来的缺点是客户端和服务器端的密钥会非常多，不好维护。4 非对称加密是：编码解码不用相同分密钥，通常来说加密的密钥是公开的密钥就是所有的人都能使用的公开的，但是在服务器解码的密钥是私有的只有服务器才能进行解码。这样就解决的密钥很多的问题。5 数字签名（有报文的内容产生，相当于tcp的检验和）：是一种防止报文被篡改的方法：就是相当于检验和。产生数字签名的方法是先根据报文的摘要，经过加密函数产生签名并附加在明文报文的最后，然后两个一起加密，发送到目的端，目的端先解码，然后再将解码后的签名进行解码，对比检验和（签名）如果没有变就说明是没有被篡改。6 证书：是权威性的组织颁发给服务器的id card，里面包括了所使用的公钥算法等。 先来看看http协议和https协议的区别。 https是安全的协议，他在http协议层和tcp层加了一层ssl（tls），会把请求和响应的数据进行加密而不是直接暴露在里面。http httptcp 安全层ssl协议ip tcp链路层 ip http的请求和https的请求默认的端口不一样：一个是80一个是443.https客户端和服务器建立传输的方式是不一样的，他首先会打开和服务器443端口的tcp连接，然后客户端和服务器进行ssl握手（就是交换客户端和服务器的协议版本号，选择一个两端都了解的密码，认证两端的身份，生成临时的会话密钥），完成之后，就可以将http报文发送到ssl层进行加密然后通过tcp发送到服务器。 常见的http状态码：1开头的是信息2开头的是表示成功了200成功3开头的表示重定向4开头的表示客服端的错误 403服务器拒绝5开头的表示服务器的错误","categories":[],"tags":[]},{"title":"mysql high perfomance","slug":"mysql-high-perfomance","date":"2017-07-21T05:30:06.000Z","updated":"2017-08-01T06:46:22.754Z","comments":true,"path":"2017/07/21/mysql-high-perfomance/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/21/mysql-high-perfomance/","excerpt":"","text":"高性能mysql 前面的有关于mysql的多线程的管理，各种锁的机制 广义的讲：锁有两种排它锁和共享锁。排它锁是在有一个线程在使用资源的时候，会将其他要访问这个资源的线程全部阻塞，知道这个线程使用完毕。（一般是更新和删除数据）共享锁是资源共享的，多个线程是能共同访问,一般是用于读取数据。 对于mysql来说又实现了两种锁粒度的锁，这样是更加的提高了效率（紧将需要修改的数据进行加锁而不用把全部的数据进行加锁）但是是相对的维护锁的成本也变高了。 1表锁 2行锁还有事务的原子性。。。。隔离级别。 事务就是一组sql的操作。 事务的特性是：1原子性 是这一组操作要么都成功要么都失败（rollback） 2一致性 是事务执行的前后的状态是一致的，比如银行转账的例子，在转账前后的钱的总数是一致的。 3隔离性 是指事务之间是有隔离性的，在一个事务没有执行完之前其他的事务是不能看到他内部的变化的，只能知道这个事务执行之前的状态。 隔离性是有等级的。一般是有4个隔离等级。 4持久性 是指在事务成功的执行了之后，数据将永久的保存到了数据库当中。隔离级别： 1 未提交读 事务在没有进行commit的时候，其他的事务就可以直接读取或修改这个事务修改过的数据。 这样会脏读（读取的数据不一定是正确的，可能会rollback） 2 提交读 只有事务在commit之后，其他事务才能看到更新后的数据。不然读到的数据都是在事务改变之前的数据（是不会对读取的数据行进行加锁的），这样会产生不可重复读，就是一个事务中两次读取的数剧可能是不相等的（前一个读的是那个事务commit之前的数据，后一个读的是commit之后的） 3 可重复读 他可以让同一个事务中多次读取的数据都是相同的。具体的实现不懂（mysql中默认是这个隔离级别） 但是也会产生幻读：产生的条件一个事务多行数据的读取和操作，然后另一个事务在其中insert或delect了一行，这样就会产生幻读。 4 串行化读 对这个事务要读取的数据行进行加锁，其他的事务就会在这个事务执行完才能执行。串行的读取数据。还有mysql的存储引擎，主要是innodb和myisam两个和其的区别。首先是InnoDB的存储引擎： 他是聚簇索引建立的B——tree里面直接存储了数据行，和索引（对于主键），二级索引的叶子节点只存储了二级索引和主键，然后通过主键来索引数据。 innodb的优势是对于主键的索引是十分快的。然后是MyISAM存储引擎： 他是非聚簇的索引，索引和数据是分开的，索引的叶子节点存储的是对应数据行的物理地址。 MyISAM相对于InnoDB是不支持事物的还不支持行级锁。在多线程的情况下只能进行整个表的锁。其数据恢复比较困难。所以在mysql中优先使用的是innodb。后面的是关于性能优化的方面：1 是从数据存储的类型说起，还有表的设计方面，有范式的设计思路有反范式的设计思路。关于范式的设计：是尽可能的减少冗余的信息，这样带来的效果是相对反范式的表，表的数量变多了，性能上的效果是update和删除的性能提升，然而对于复杂的查询任务性能是比较差的关于反范式的设计是尽量用一张表来实现这样做的表现是表的数量比较少，冗余的信息比较多（但对于复杂的查询性能比较好），更新和删除的内容比较多。2关于索引的优化（索引的优化是查询性能优化最有效的手段了）首先是索引的概念：就像是字典的索引一样，便于查找到相对应的行的信息。（一般是把主键来当作索引，但是两个是不同的概念）一个表中可以有多个索引。最简单的索引的实现可以用红黑树:节点存的是key和value的物理地址，Mysql中索引的实现使用B+tree数据结构（是2，3树红黑树的一种扩展）（这是面向磁盘和ssd存储的数据结构）来实现也有其他的实现的方式。还有查找二叉树这种查找性能很好的数据结构，但是不适合于磁盘的存储。（当然对于内存的存贮并没有什么区别，关键是磁盘的io代价比较大）B-Tree的特点：(1)树的高度是相对平衡二叉树低的多。 (2)相对之前的节点，他的是一个数组（不是链表）。 (3)他的叶子节点上存的是value（物理地址），其他的节点存的是有序的key（是key（不是主键而是辅助的key）和子节点的指针交替的排列）B+tree相对新加的两条约束是叶子节点是相互连接的（一个叶子节点的最后一个元素是下一个叶子节点的地址）这样的好处是当要查找连续的key时就可以直接按照顺序遍历过去，不用从root节点重新查找了。不同的存储引擎是有不同的实现：Myisam中叶子节点存的就是物理地址（这种索引的方式是非聚集的）辅助的索引不是主键Innodb索引的实现：聚集的，他的叶子节点存的是data。辅助的索引是主键。难道不是所有的查询都用到索引?答案是肯定的索引也可以有多个列。但是在定义index的时候列的顺序是十分重要的查询的分类(1)全值匹配:查询时是按照多有的列来进行查找WHERE emp_no=’10001’ AND title=’Senior Engineer’ AND from_date=’1986-06-26’; (2)匹配最左前缀：只查询第一列 (3)范围查询（查找一个范围内的行） (4)只匹配列的前缀。（在性能优化里用的多）在使用index的一些限制：只能按照顺序来进行查找，不能跳过某一个（当然最后一个除外），然后是其中一个index是范围查找的时候后面的index就不能进行匹配了会自动失效。WHERE emp_no=’10001’ AND title LIKE ‘Senior%’;索引的优点：带来了查询性能的提升。缺点：建立索引本身是要消耗存储空间和维护索引。不使用索引的情况：当表中的数据比较小的时候，大概是小于2000条的时候，就用不到，直接扫描全表就是了。mysql查询的分类（有索引） 一个索引优化和建立的例子：表employee中只有一个主键id；但是我想要按照first name和lastname来查询：如果没有建立index就会遍历整个表的数据来进行查找。效率是比较低。所以考虑加入first name和lastname的index。但是我又不想增加index过多的长度。那就可以考虑使用列前缀indexALTER TABLE employees.employeesADD INDEX first_name_last_name4 (first_name, last_name(4));这里只用匹配lastname的前四个。这样查询的性能又好，然而index带来的副作用又少。有关于innodb引擎优化的一些建议:使用和业务没有关系的可以自增的列作为主键。","categories":[],"tags":[]},{"title":"","slug":"String","date":"2017-07-15T10:42:36.689Z","updated":"2017-07-15T10:42:36.687Z","comments":true,"path":"2017/07/15/String/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/15/String/","excerpt":"","text":"title: Stringdate: 2017-07-15 18:30:27 tags:有关于字符串的算法题目，主要是原地的（空间复杂度是常数）也就是原地的进行操作，一般有左右开工，有两个游标1进行交换swap操作partition过程将比某一个数字大的放到一边然后小的放到另一边，会改变原有的顺序。2或者进行移位（要求数组的长度比较长）这个不会改变原来的顺序3还有就是有一个滑动窗口的算法，来进行子字符串的一些算法题目,用两个int值来表示窗口的左边界和右边界。见leetcode第三题。","categories":[],"tags":[]},{"title":"weekends","slug":"weekends","date":"2017-07-15T10:25:09.000Z","updated":"2017-07-15T10:29:53.365Z","comments":true,"path":"2017/07/15/weekends/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/15/weekends/","excerpt":"","text":"周末终于有时间来充电了，但是现在却没有心思来学习，关键是这几个算法题目太难了，今天能把字符串的东西看就已经很好了，想去跑步但是太热了，还是需要来调节一下的，还有每天上班回来可以先休息半小时，然后再进入学习的状态，反正最近的学习任务比较重，不然以后连笔试都过不了就尴尬了。","categories":[],"tags":[]},{"title":"leetcode test","slug":"leetcode-test","date":"2017-07-14T15:14:10.000Z","updated":"2017-07-14T15:18:46.796Z","comments":true,"path":"2017/07/14/leetcode-test/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/14/leetcode-test/","excerpt":"","text":"这几天一直在看leetcode的算法题目。目前已经看完了链表的题目，只是经典的题目，现在先把july edu的算法公开课刷完，然后对应leetcode上的题目做，一个一个table做。然后算法和数据结构的题目就到此为止了，后面要看的书是java分布式的一些东西还有mysql高性能的东西，然后要把实习的东西做一个总结，后面再复习复习基础的知识，然后就可以面试了。不知道选择题要不要刷。后面在看吧。","categories":[],"tags":[]},{"title":"whatever","slug":"whatever","date":"2017-07-03T09:10:19.000Z","updated":"2017-07-03T09:12:48.642Z","comments":true,"path":"2017/07/03/whatever/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/03/whatever/","excerpt":"","text":"recently i am studing the algorithms about the linked list ,tree,hashmap.and so on,i can do some test about it.maybe i can buy some books which i can read it on working day.","categories":[],"tags":[]},{"title":"","slug":"the-new-home","date":"2017-07-02T13:37:05.293Z","updated":"2017-07-02T13:37:05.291Z","comments":true,"path":"2017/07/02/the-new-home/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/07/02/the-new-home/","excerpt":"","text":"title: the new homedate: 2017-07-02 21:34:51tags:—在研二快结束的时候我们从三牌楼搬到了仙林校区，虽然环境变得好了一点但是交通实在是不方便，以后就在教研室了。。。","categories":[],"tags":[]},{"title":"the usage of git ","slug":"the-usage-of-git","date":"2017-06-07T08:43:37.000Z","updated":"2017-06-07T08:51:41.712Z","comments":true,"path":"2017/06/07/the-usage-of-git/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/06/07/the-usage-of-git/","excerpt":"","text":"generally ,we always using the commond :git remote origin ;to bind this remote repo to the name:origin .if we pull or push we can using origin rather than the url or ssh..when you change the file in your working zone,you must add and commit .then push to the remote repo.if you want to rollback this add or remove,you can use the commond git reset HEAD filename;and if you want to checkout the branch but there are change in add zone,you need to stash the change,then you can checkout to other branch,when you return to the first branch ,you can use the commond :git stash pop .","categories":[],"tags":[]},{"title":"my first blogls","slug":"my-first-blogls","date":"2017-06-06T13:10:58.000Z","updated":"2017-06-06T13:10:58.430Z","comments":true,"path":"2017/06/06/my-first-blogls/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/06/06/my-first-blogls/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2017-06-06T12:56:10.000Z","updated":"2017-06-06T12:58:07.176Z","comments":true,"path":"2017/06/06/my-first-blog/","link":"","permalink":"https://sbw6788778.github.io/blog/2017/06/06/my-first-blog/","excerpt":"","text":"my life is fuirtable.","categories":[],"tags":[]}]}